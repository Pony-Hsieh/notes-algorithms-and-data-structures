# 複雜度
## 時間複雜度
- 最壞情況：O(n^2)
- 平均情況：O(n log n)
- 最佳情況：O(n log n)
## 空間複雜度
- O(log n)


# 優缺點
## 特點
- 是一種遞迴的演算法，遞迴 partition 這個 function
- 也有使用到 Divide and Conquer 的概念
- quick sort 與 merge sort 一樣，都採用 divide & conquer 的策略。不過在切割的部分與 merge sort 不同的是，merge sort 每次切割都是剖半，而 quick sort 則與該次切割時所選的 pivot 有關。
- 由於切割的大小會隨著 pivot 的不同，而產生不同的子數列，也使得切割次數不定。
  - 最佳情況： 每次都剛好切割為相同大小的子數列，這時候就會使得切割次數為 log2n 次
  - 最差情況： 每次切割都僅僅將原數列分為 0 與 n - 1（扣除 pivot），也就是 pivot 剛好都取到該數列中的最大或最小值，則可能會有 n 次的遞迴呼叫。
  - 所以 quick sort 的時間複雜度分為最佳時為 O(n log n)，最差為 O(n^2)。
- 在 in-place 版本中，假設 pivot 選得好(剛好是中位數)，就可以有一半的元素不用交換，因為只有小於的 pivot 的元素需要被交換，大於等於的就擺著即可
## 優點
- 快速排序通常比其他 O(n log n) 的演算法（如歸併排序、堆排序）速度更快，因為它的內部循環代價低。
- 它是原地排序，節省了額外的存儲空間。
## 缺點
- 快速排序的最壞情況時間複雜度是 O(n^2)，儘管這種情況可以透過隨機選擇基準點或使用三數取中法（Median-of-three）來緩解
- 遞迴深度過深時，可能導致棧溢出（Stack Overflow）
- 不是 stable 排序



# partition
- 做完 partition 之後，唯一被排序好的，就是那個 pivot
## 步驟
1. 選擇基準點（Pivot）：
   - 通常可以選擇陣列的第一個元素、最後一個元素，或是隨機選擇一個元素
2. 設置指標：
   - 設置兩個指標：一個指向陣列的起始位置（通常是左指標 i），一個指向陣列的結尾位置（通常是右指標 j）。
3. 移動指標：
   - 左指標 i 從左到右移動，直到找到一個大於基準點的元素為止。
   - 右指標 j 從右到左移動，直到找到一個小於基準點的元素為止。
4. 交換元素：
   - 當 i 和 j 都找到了相對應的元素時，交換這兩個元素的位置。
   - 重複上述步驟，直到左指標 i 超過右指標 j。
5. 分割點：
   - 當 i 超過 j 時，停止分割。此時，基準點的正確位置已經確定，左側的所有元素都小於基準點，右側的所有元素都大於基準點。

# 參考文章
- [[Sort] 淺談 quick sort](https://blog.kuoe0.tw/posts/2013/03/15/sort-about-quick-sort/)