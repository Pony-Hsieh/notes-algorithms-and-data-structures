# 特性
- 一種分治法（Divide and Conquer）演算法
  - Divide and Conquer 通常會與 遞迴 一起使用

無論甚麼狀況下，merge sort 的時間複雜度都會是 O(n log n) 對嗎

# 複雜度
## 時間複雜度
- 最壞情況：O(n log n)
- 平均情況：O(n log n)
- 最佳情況：O(n log n)
- 無論在最佳、最壞或平均情況下，合併排序（Merge Sort）的時間複雜度都是 O(n log n)，原因如下：
  1. 分割階段（Divide）：
     - 將數據集二分直到每個部分只剩下一個元素，這部分的操作需要 O(log n) 的時間
  2. 合併階段（Conquer/Merge）：
     - 在合併階段，每一層的合併操作都需要遍歷所有的元素，因此這部分的操作需要 O(n) 的時間
  3. 總時間複雜度：
     - 因此，整個合併排序的時間複雜度是這兩部分的乘積，也就是 O(n) * O(log n) = O(n log n)
## 空間複雜度
- O(n)
  - merge sort 需要額外的輔助空間來存儲分割後的數據，特別是在合併階段，需要額外的空間來存放臨時的合併結果。


# 優缺點
## 優點
1. **穩定性**：合併排序是穩定的排序演算法，意思是在排序後相同鍵值的元素相對次序不變。
2. **時間複雜度**：在最壞、最佳和平均情況下，合併排序的時間複雜度都是 O(n log n)，這使它在處理大數據時表現出色。
3. **適合外部排序**：合併排序在處理非常大的數據集（例如，無法一次性載入記憶體的數據集）時非常有用，因為它是基於順序存取和合併的。

## 缺點
1. **空間複雜度**：合併排序需要額外的空間來存儲臨時陣列，因此空間複雜度為 O(n)。這可能在記憶體有限的情況下成為一個問題。
2. **常數因子較大**：相比於其他排序演算法（如快速排序），合併排序的常數因子較大，這意味著在小數據集上，它的性能可能不如其他排序演算法。

## 適合的情況
1. **大型數據集**：當處理非常大的數據集時，合併排序的穩定性和 O(n log n) 的時間複雜度使其非常適合。
2. **需要穩定排序**：如果需要保持相同鍵值的元素順序，合併排序是合適的選擇。
3. **外部排序**：當數據集大到無法一次性載入記憶體時，合併排序在分割和合併過程中非常有效。

總結來說，合併排序非常適合處理需要穩定性、外部排序或是大型數據集的情況，但在空間限制和小數據集的情況下，可能需要考慮其他演算法。